name: Windows Build

permissions:
  contents: write

on:
  push:
    tags:
      - 'v*'

concurrency:
  group: windows-build
  cancel-in-progress: true

jobs:
  build-windows:
    name: Build Windows App
    runs-on: windows-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 'latest'

      - name: Cache pnpm store and node_modules
        uses: actions/cache@v4
        with:
          path: |
            ~/.pnpm-store
            node_modules
          key: pnpm-${{ runner.os }}-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            pnpm-${{ runner.os }}-

      - name: Install dependencies
        run: pnpm install

      - name: Install Rust via rustup (stable)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          Write-Host "Downloading rustup-init.exe"
          Invoke-WebRequest -Uri 'https://win.rustup.rs' -UseBasicParsing -OutFile 'rustup-init.exe'
          Write-Host "Running rustup-init.exe (non-interactive)"
          Start-Process -FilePath .\rustup-init.exe -ArgumentList '-y','--no-modify-path','--default-toolchain','stable' -Wait
          Remove-Item .\rustup-init.exe
          # Add cargo bin to PATH for remaining steps
          $cargo = "$env:USERPROFILE\\.cargo\\bin"
          Add-Content -Path $env:GITHUB_PATH -Value $cargo
          Write-Host "rustup and rustc versions:"
          rustup --version
          rustc --version

      - name: Cache Cargo registry and git
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          key: cargo-registry-${{ runner.os }}-${{ hashFiles('src-tauri/Cargo.lock') }}
          restore-keys: |
            cargo-registry-${{ runner.os }}-

      - name: Cache Cargo build target (optional)
        uses: actions/cache@v4
        with:
          path: src-tauri/target
          key: cargo-target-${{ runner.os }}-${{ hashFiles('src-tauri/Cargo.lock') }}
          restore-keys: |
            cargo-target-${{ runner.os }}-

      - name: Compute release version from tag
        id: ver
        shell: pwsh
        run: |
          # GITHUB_REF example: refs/tags/v0.1.1
          $ref = $env:GITHUB_REF
          $ver = $ref -replace '^refs/tags/v', ''
          Write-Output "version=$ver" >> $env:GITHUB_OUTPUT

      - name: Remove .gitkeep files in src-tauri
        shell: pwsh
        run: |
          Get-ChildItem -Path 'src-tauri' -Recurse -Filter '.gitkeep' -ErrorAction SilentlyContinue | ForEach-Object { Remove-Item -LiteralPath $_.FullName -Force }

      - name: Generate Tauri icons
        run: pnpm tauri icon ./app-icon.svg

      - name: Generate prerendered icons
        run: pnpm icons

      - name: Build Tauri (release)
        run: pnpm tauri build --no-bundle

      - name: Gather release binaries to sign
        if: ${{ secrets.CERT_PFX != '' && secrets.CERT_PASSWORD != '' }}
        id: gather_sign_files
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $root = Join-Path $PWD 'src-tauri\target\release'
          Write-Host "Searching for .exe and .dll under $root"
          $items = Get-ChildItem -Path $root -Recurse -Include *.exe,*.dll -File -ErrorAction SilentlyContinue | Select-Object -ExpandProperty FullName
          if (-not $items) {
            Write-Host "No binaries found to sign"
            Write-Output "files=" >> $env:GITHUB_OUTPUT
            exit 0
          }
          $joined = $items -join ';'
          Write-Host "Found $($items.Count) files to sign"
          Write-Output "files=$joined" >> $env:GITHUB_OUTPUT

      - name: Sign internal release binaries (Authenticode)
        if: ${{ secrets.CERT_PFX != '' && secrets.CERT_PASSWORD != '' && steps.gather_sign_files.outputs.files != '' }}
        uses: ./.github/actions/authenticode-sign
        with:
          files: ${{ steps.gather_sign_files.outputs.files }}
        env:
          CERT_PFX: ${{ secrets.CERT_PFX }}
          CERT_PASSWORD: ${{ secrets.CERT_PASSWORD }}

      - name: Bundle Tauri
        run: pnpm tauri bundle

      - name: Bundle portable
        run: pnpm bundle:portable

      - name: Collect artifacts
        id: collect
        shell: pwsh
        env:
          VERSION: ${{ steps.ver.outputs.version }}
        run: |
          New-Item -ItemType Directory -Path artifacts -Force | Out-Null

          $nsis = Get-ChildItem -Path 'src-tauri\target\release\bundle\nsis' -Filter '*.exe' -Recurse -ErrorAction SilentlyContinue | Select-Object -Last 1
          if (-not $nsis) { Write-Error "NSIS installer not found in src-tauri\target\release\bundle\nsis"; exit 1 }
          $nsisDest = Join-Path $PWD $nsis.Name
          Copy-Item $nsis.FullName -Destination (Join-Path $PWD 'artifacts' $nsis.Name)

          $portable = Get-ChildItem -Path 'src-tauri\target\release\bundle\portable_win' -Filter '*.exe' -Recurse -ErrorAction SilentlyContinue | Select-Object -Last 1
          if (-not $portable) { Write-Error "Portable exe not found in src-tauri\target\release\bundle\portable_win"; exit 1 }
          Copy-Item $portable.FullName -Destination (Join-Path $PWD 'artifacts' $portable.Name)

          Write-Output "nsis_artifact=$($nsis.Name)" >> $env:GITHUB_OUTPUT
          Write-Output "portable_artifact=$($portable.Name)" >> $env:GITHUB_OUTPUT

      - name: Sign artifacts with GPG
        if: ${{ secrets.GPG_PRIVATE_KEY != '' }}
        uses: ./.github/actions/gpg-sign
        with:
          files: |
            artifacts/${{ steps.collect.outputs.nsis_artifact }};artifacts/${{ steps.collect.outputs.portable_artifact }}
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}

      - name: Sign bundled artifacts (Authenticode)
        if: ${{ secrets.CERT_PFX != '' && secrets.CERT_PASSWORD != '' }}
        uses: ./.github/actions/authenticode-sign
        with:
          files: |
            artifacts/${{ steps.collect.outputs.nsis_artifact }};artifacts/${{ steps.collect.outputs.portable_artifact }}
        env:
          CERT_PFX: ${{ secrets.CERT_PFX }}
          CERT_PASSWORD: ${{ secrets.CERT_PASSWORD }}

      - name: Verify Authenticode signatures on artifacts
        if: ${{ secrets.CERT_PFX != '' && secrets.CERT_PASSWORD != '' }}
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $nsis = Join-Path $PWD "artifacts/${{ steps.collect.outputs.nsis_artifact }}"
          $portable = Join-Path $PWD "artifacts/${{ steps.collect.outputs.portable_artifact }}"

          $files = @($nsis, $portable)
          foreach ($f in $files) {
            if (Test-Path $f) {
              Write-Host "Running signtool verify on: $f"
              & signtool verify /pa /v $f
              if ($LASTEXITCODE -ne 0) {
                Write-Error "signtool verification failed for $f"
                exit 1
              }
            } else {
              Write-Host "Not found, skipping verification: $f"
            }
          }

      - name: Create GitHub Release
        id: create_release
        uses: actions/create-release@v1
        with:
          tag_name: ${{ github.ref_name }}
          release_name: Switchboot ${{ steps.ver.outputs.version }} released
          body: Switchboot ${{ steps.ver.outputs.version }} released
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Export public GPG key
        if: ${{ secrets.GPG_PRIVATE_KEY != '' }}
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $gnupghome = Join-Path $env:RUNNER_TEMP 'gnupghome'
          New-Item -ItemType Directory -Path $gnupghome -Force | Out-Null
          $env:GNUPGHOME = $gnupghome

          $keyPath = Join-Path $gnupghome 'private.key'
          [System.IO.File]::WriteAllText($keyPath, $env:GPG_PRIVATE_KEY)
          gpg --batch --import $keyPath
          Remove-Item $keyPath -Force

          $pubOut = Join-Path $PWD 'artifacts/public_gpg_key.asc'
          gpg --batch --armor --export > $pubOut
          Write-Host "Exported public key to $pubOut"

      - name: Upload public GPG key to release
        if: ${{ secrets.GPG_PRIVATE_KEY != '' }}
        uses: actions/upload-release-asset@v1
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: artifacts/public_gpg_key.asc
          asset_name: public_gpg_key.asc
          asset_content_type: text/plain
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload NSIS installer to release
        uses: actions/upload-release-asset@v1
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: artifacts/${{ steps.collect.outputs.nsis_artifact }}
          asset_name: ${{ steps.collect.outputs.nsis_artifact }}
          asset_content_type: application/octet-stream
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload Portable to release
        uses: actions/upload-release-asset@v1
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: artifacts/${{ steps.collect.outputs.portable_artifact }}
          asset_name: ${{ steps.collect.outputs.portable_artifact }}
          asset_content_type: application/octet-stream
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

