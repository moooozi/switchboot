name: Windows Build

permissions:
  contents: write

on:
  push:
    tags:
      - "v*"

concurrency:
  group: windows-build
  cancel-in-progress: true

jobs:
  build-windows:
    name: Build Windows App
    runs-on: windows-latest
    # do not map secrets at job-level to minimize blast radius; set them on steps that need them

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check for signing secrets
        id: secrets_check
        shell: pwsh
        run: |
          # Write whether cert and gpg secrets are present to outputs (do not print secret values)
          $hasCert = if ('${{ secrets.CERT_PFX }}' -ne '' -and '${{ secrets.CERT_PASSWORD }}' -ne '') { 'true' } else { '' }
          $hasGpg = if ('${{ secrets.GPG_PRIVATE_KEY }}' -ne '') { 'true' } else { '' }
          $hasRoot = if ('${{ secrets.CERT_ROOT }}' -ne '') { 'true' } else { '' }
          Write-Output "have_cert=$hasCert" >> $env:GITHUB_OUTPUT
          Write-Output "have_gpg=$hasGpg" >> $env:GITHUB_OUTPUT
          Write-Output "have_root=$hasRoot" >> $env:GITHUB_OUTPUT

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: "latest"

      - name: Cache pnpm store and node_modules
        uses: actions/cache@v4
        with:
          path: |
            ~/.pnpm-store
            node_modules
          key: pnpm-${{ runner.os }}-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            pnpm-${{ runner.os }}-

      - name: Install dependencies
        run: pnpm install

      - name: Install Rust via rustup (stable)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          Write-Host "Downloading rustup-init.exe"
          Invoke-WebRequest -Uri 'https://win.rustup.rs' -UseBasicParsing -OutFile 'rustup-init.exe'
          Write-Host "Running rustup-init.exe (non-interactive)"
          Start-Process -FilePath .\rustup-init.exe -ArgumentList '-y','--no-modify-path','--default-toolchain','stable' -Wait
          Remove-Item .\rustup-init.exe
          # Add cargo bin to PATH for remaining steps
          $cargo = "$env:USERPROFILE\\.cargo\\bin"
          Add-Content -Path $env:GITHUB_PATH -Value $cargo
          Write-Host "rustup and rustc versions:"
          rustup --version
          rustc --version

      - name: Cache Cargo registry and git
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          key: cargo-registry-${{ runner.os }}-${{ hashFiles('src-tauri/Cargo.lock') }}
          restore-keys: |
            cargo-registry-${{ runner.os }}-

      - name: Cache Cargo build target (optional)
        uses: actions/cache@v4
        with:
          path: src-tauri/target
          key: cargo-target-${{ runner.os }}-${{ hashFiles('src-tauri/Cargo.lock') }}
          restore-keys: |
            cargo-target-${{ runner.os }}-

      - name: Compute release version from tag
        id: ver
        shell: pwsh
        run: |
          # GITHUB_REF example: refs/tags/v0.1.1
          $ref = $env:GITHUB_REF
          $ver = $ref -replace '^refs/tags/v', ''
          Write-Output "version=$ver" >> $env:GITHUB_OUTPUT

      - name: Locate signtool (Windows SDK) and add to PATH
        id: find_signtool
        uses: ./.github/actions/ensure-signtool

      - name: Fail early if signing is requested but signtool not found
        if: ${{ steps.secrets_check.outputs.have_cert == 'true' && steps.find_signtool.outputs.signtool_path == '' }}
        shell: pwsh
        run: |
          Write-Error 'CERT_PFX secret present but signtool.exe was not found on the runner. Cannot perform Authenticode signing.'
          exit 1

      - name: Install signing root certificate (optional)
        if: ${{ steps.secrets_check.outputs.have_root == 'true' }}
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          Write-Host "Installing signing root certificate (from secret CERT_ROOT) into the certificate store"
          $certRaw = '${{ secrets.CERT_ROOT }}'
          if (-not $certRaw -or $certRaw -eq '') {
            Write-Host "CERT_ROOT appears empty, skipping"
            exit 0
          }
          $certPath = Join-Path $env:RUNNER_TEMP 'codesign_root.cer'
          [IO.File]::WriteAllBytes($certPath, [Convert]::FromBase64String($certRaw))
          # Try adding to the LocalMachine Root store first; fallback to CurrentUser if that fails
          try {
            Write-Host "Adding certificate to LocalMachine\\Root"
            certutil -addstore -f Root $certPath
          } catch {
            Write-Host "Failed to add to LocalMachine store, trying CurrentUser store"
            certutil -user -addstore -f Root $certPath
          }
          Remove-Item $certPath -Force

      - name: Install cert chain from provided PFX (fallback when CERT_ROOT not provided)
        if: ${{ steps.secrets_check.outputs.have_cert == 'true' && steps.secrets_check.outputs.have_root != 'true' }}
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          Write-Host 'No separate CERT_ROOT provided; extracting certificates from CERT_PFX and installing into CurrentUser stores'
          $pfxRaw = '${{ secrets.CERT_PFX }}'
          if (-not $pfxRaw -or $pfxRaw -eq '') {
            Write-Host 'CERT_PFX appears empty, skipping'
            exit 0
          }
          $pwd = '${{ secrets.CERT_PASSWORD }}'
          $pfxPath = Join-Path $env:RUNNER_TEMP 'codesign_from_pfx.pfx'
          [IO.File]::WriteAllBytes($pfxPath, [Convert]::FromBase64String($pfxRaw))

          # Load all certificates from PFX
          $secure = ConvertTo-SecureString $pwd -AsPlainText -Force
          $collection = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2Collection
          # Use the X509KeyStorageFlags enum (not a string) so the correct overload is called
          $keyFlags = [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::Exportable -bor [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::PersistKeySet
          try {
            $collection.Import($pfxPath, $secure, $keyFlags)
          } catch {
            Write-Error "Failed to import PFX: $($_.Exception.Message)"
            throw
          }

          foreach ($c in $collection) {
            $subject = $c.Subject
            $issuer = $c.Issuer
            $thumb = $c.Thumbprint
            $tmp = Join-Path $env:RUNNER_TEMP ($thumb + '.cer')
            [IO.File]::WriteAllBytes($tmp, $c.Export([System.Security.Cryptography.X509Certificates.X509ContentType]::Cert))
            if ($subject -eq $issuer) {
              Write-Host "Adding self-signed cert to CurrentUser\\Root: $subject"
              certutil -user -addstore -f Root $tmp
            } else {
              Write-Host "Adding intermediate/other cert to CurrentUser\\CA: $subject"
              certutil -user -addstore -f CA $tmp
            }
            Remove-Item $tmp -Force
          }

          Remove-Item $pfxPath -Force

      - name: Remove .gitkeep files in src-tauri
        shell: pwsh
        run: |
          Get-ChildItem -Path 'src-tauri' -Recurse -Filter '.gitkeep' -ErrorAction SilentlyContinue | ForEach-Object { Remove-Item -LiteralPath $_.FullName -Force }

      - name: Generate Tauri icons
        run: pnpm tauri icon ./app-icon.svg

      - name: Generate prerendered icons
        run: pnpm icons

      - name: Build Tauri (release)
        run: pnpm tauri build --no-bundle

      - name: Gather release binaries to sign
        if: ${{ steps.secrets_check.outputs.have_cert == 'true' }}
        id: gather_sign_files
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $root = Join-Path $PWD 'src-tauri\target\release'
          Write-Host "Searching for .exe and .dll under $root"
          $items = Get-ChildItem -Path $root -Recurse -Include *.exe,*.dll -File -ErrorAction SilentlyContinue | Select-Object -ExpandProperty FullName
          if (-not $items) {
            Write-Host "No binaries found to sign"
            Write-Output "files=" >> $env:GITHUB_OUTPUT
            exit 0
          }
          $joined = $items -join ';'
          Write-Host "Found $($items.Count) files to sign"
          Write-Output "files=$joined" >> $env:GITHUB_OUTPUT

      - name: Sign internal release binaries (Authenticode)
        if: ${{ steps.secrets_check.outputs.have_cert == 'true' && steps.gather_sign_files.outputs.files != '' }}
        uses: ./.github/actions/authenticode-sign
        with:
          files: ${{ steps.gather_sign_files.outputs.files }}
        env:
          CERT_PFX: ${{ secrets.CERT_PFX }}
          CERT_PASSWORD: ${{ secrets.CERT_PASSWORD }}

      - name: Bundle Tauri
        run: pnpm tauri bundle

      - name: Bundle portable
        run: pnpm bundle:portable

      - name: Collect artifacts
        id: collect
        shell: pwsh
        env:
          VERSION: ${{ steps.ver.outputs.version }}
        run: |
          New-Item -ItemType Directory -Path artifacts -Force | Out-Null

          $nsis = Get-ChildItem -Path 'src-tauri\target\release\bundle\nsis' -Filter '*.exe' -Recurse -ErrorAction SilentlyContinue | Select-Object -Last 1
          if (-not $nsis) { Write-Error "NSIS installer not found in src-tauri\target\release\bundle\nsis"; exit 1 }
          $nsisDest = Join-Path $PWD $nsis.Name
          Copy-Item $nsis.FullName -Destination (Join-Path $PWD 'artifacts' $nsis.Name)

          $portable = Get-ChildItem -Path 'src-tauri\target\release\bundle\portable_win' -Filter '*.exe' -Recurse -ErrorAction SilentlyContinue | Select-Object -Last 1
          if (-not $portable) { Write-Error "Portable exe not found in src-tauri\target\release\bundle\portable_win"; exit 1 }
          Copy-Item $portable.FullName -Destination (Join-Path $PWD 'artifacts' $portable.Name)

          Write-Output "nsis_artifact=$($nsis.Name)" >> $env:GITHUB_OUTPUT
          Write-Output "portable_artifact=$($portable.Name)" >> $env:GITHUB_OUTPUT

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: windows-artifacts-${{ steps.ver.outputs.version }}
          path: artifacts/*
