name: Update Package Repository

on:
  workflow_call:
    inputs:
      version:
        description: "Version to update repository for (e.g. v0.1.1)"
        required: true
        type: string
  workflow_dispatch:
    inputs:
      version:
        description: "Version to update repository for (e.g. v0.1.1)"
        required: true
        type: string

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: update-repository
  cancel-in-progress: true

jobs:
  update-repository:
    name: Update Package Repository
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check for GPG secrets
        id: secrets_check
        shell: bash
        run: |
          if [ -n "${{ secrets.GPG_PRIVATE_KEY }}" ]; then
            echo "have_gpg=true" >> $GITHUB_OUTPUT
          else
            echo "have_gpg=" >> $GITHUB_OUTPUT
          fi

      - name: Download signed artifacts (includes .asc files)
        uses: actions/download-artifact@v4
        with:
          name: signed-artifacts-${{ inputs.version }}
          path: artifacts

      - name: Download existing repository
        shell: bash
        run: |
          set -e
          echo "Downloading existing repository from GitHub Pages..."
          # Construct GitHub Pages base URL dynamically so forks/workflows don't need hardcoded owner/repo
          # GITHUB_REPOSITORY is provided by the runner in the form 'owner/repo'
          OWNER="${GITHUB_REPOSITORY%%/*}"
          REPO="${GITHUB_REPOSITORY#*/}"
          PAGES_BASE_URL="https://${OWNER}.github.io/${REPO}"
          echo "Using Pages base URL: ${PAGES_BASE_URL}"
          mkdir -p repo/rpm/x86_64
          mkdir -p repo/deb/pool/main/s/switchboot
          mkdir -p repo/deb/dists/stable/main/binary-amd64

          # Try to download existing packages (ignore failures for first release)
          echo "Attempting to download existing RPM packages..."
          # NOTE: Do NOT exclude repodata here. We need existing repodata when present
          # so we can update/merge repository metadata instead of replacing it.
          wget -r -np -nH --cut-dirs=1 -R "index.html*" \
            ${PAGES_BASE_URL}/rpm/x86_64/ -P repo || echo "No existing RPM packages found (this is OK for first release)"

          echo "Attempting to download existing DEB packages..."
          wget -r -np -nH --cut-dirs=1 -R "index.html*" -A "*.deb" \
            ${PAGES_BASE_URL}/deb/pool/main/s/switchboot/ -P repo || echo "No existing DEB packages found (this is OK for first release)"

          echo "Attempting to download existing signatures archive..."
          if wget -q ${PAGES_BASE_URL}/signatures.tar.xz -O /tmp/signatures.tar.xz; then
            echo "Signatures archive found, extracting..."
            mkdir -p repo/signatures
            tar -xJf /tmp/signatures.tar.xz -C repo/
            rm /tmp/signatures.tar.xz
            echo "Extracted existing signatures:"
            find repo/signatures -type f | head -20
          else
            echo "No existing signatures archive found (this is OK for first release)"
            mkdir -p repo/signatures
          fi

          echo "Attempting to download existing updates archive..."
          if wget -q ${PAGES_BASE_URL}/updates.tar.xz -O /tmp/updates.tar.xz; then
            echo "Updates archive found, extracting..."
            mkdir -p repo/updates
            tar -xJf /tmp/updates.tar.xz -C repo/
            rm /tmp/updates.tar.xz
            echo "Extracted existing updates:"
            find repo/updates -type f | head -20
          else
            echo "No existing updates archive found (this is OK for first release)"
            mkdir -p repo/updates
          fi

      - name: Setup repository structure
        shell: bash
        run: |
          set -e
          echo "Adding new artifacts to repository structure..."

          echo "Copying new RPM packages..."
          if ls artifacts/*.rpm 1> /dev/null 2>&1; then
            cp artifacts/*.rpm repo/rpm/x86_64/
            echo "Added new RPM packages"
            ls -la repo/rpm/x86_64/*.rpm
          else
            echo "No new RPM packages found"
          fi

          echo "Copying new DEB packages..."
          if ls artifacts/*.deb 1> /dev/null 2>&1; then
            cp artifacts/*.deb repo/deb/pool/main/s/switchboot/
            echo "Added new DEB packages"
            ls -la repo/deb/pool/main/s/switchboot/*.deb
          else
            echo "No new DEB packages found"
          fi

          echo "Copying new update signatures..."
          mkdir -p repo/updates/${{ inputs.version }}
          if ls artifacts/update-sig/*.sig 1> /dev/null 2>&1; then
            cp artifacts/update-sig/*.sig repo/updates/${{ inputs.version }}/
            echo "Added new update signatures"
            ls -la repo/updates/${{ inputs.version }}/*.sig
          else
            echo "No new update signatures found"
          fi

          echo "Copying repository configuration files..."
          cp repo-config/switchboot.repo repo/rpm/
          cp repo-config/switchboot.list repo/deb/
          cp repo-config/index.html repo/index.html

          echo "Repository contents summary:"
          echo "RPM packages:"
          ls -la repo/rpm/x86_64/ || echo "No RPM directory"
          echo "DEB packages:"
          ls -la repo/deb/pool/main/s/switchboot/ || echo "No DEB directory"

      - name: Setup signature hosting directory
        shell: bash
        run: |
          echo "Setting up signatures directory..."
          mkdir -p repo/signatures/${{ inputs.version }}

          # Copy all new .asc files to the signatures directory
          if ls artifacts/*.asc 1> /dev/null 2>&1; then
            cp artifacts/*.asc repo/signatures/${{ inputs.version }}/
            echo "Copied signature files:"
            ls -la repo/signatures/${{ inputs.version }}/
          else
            echo "No signature files found"
          fi

      - name: Install system dependencies
        shell: bash
        run: |
          set -e
          echo "Installing repository management tools..."
          sudo apt-get update
          sudo apt-get install -y createrepo-c dpkg-dev apt-utils rpm

      - name: Generate latest.json for updates
        shell: bash
        run: |
          set -e
          echo "Generating latest.json for updates..."
          python3 scripts/generate_latest_json.py "${{ inputs.version }}" "${PAGES_BASE_URL}"

      - name: Export GPG public key
        if: steps.secrets_check.outputs.have_gpg == 'true'
        shell: bash
        run: |
          set -e
          echo "Setting up GPG and exporting public key..."
          # import private key so we can export the public part
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --import

          # Export RPM-style ASCII public key for RPM consumers
          gpg --armor --export > repo/rpm/RPM-GPG-KEY-switchboot

          # Export a dearmored binary keyring suitable for apt's signed-by usage
          gpg --export | gpg --dearmor > repo/deb/switchboot-archive-keyring.gpg

          echo "GPG public key exported successfully"

      - name: Prune repository (new logic)
        shell: bash
        run: |
          set -euo pipefail
          # Determine prune flags
          PRUNE_ALLOW_GREATER=0
          if [ -f repo-config/PRUNE_ALLOW_GREATER_VERSION ]; then
            PRUNE_ALLOW_GREATER=1
            echo "PRUNE_ALLOW_GREATER_VERSION present: newer-than-current versions will be preserved during prune"
          fi

          if [ -f repo-config/FORCE_DISABLE_PRUNE ]; then
            echo "FORCE_DISABLE_PRUNE present: skipping pruning step"
          else
            echo "Running prune script with current version: ${INPUTS_VERSION:-${{ inputs.version }}}"
            python3 scripts/prune_repo.py repo "switchboot" "${{ inputs.version }}" $PRUNE_ALLOW_GREATER || true
          fi

      - name: Generate RPM repository metadata
        shell: bash
        run: |
          set -e
          echo "Generating RPM repository metadata..."
          if ls repo/rpm/x86_64/*.rpm 1> /dev/null 2>&1; then
            # If repodata already exists (from previous published site) use --update
            # to merge new packages into existing metadata. Otherwise create fresh metadata.
            if [ -d "repo/rpm/x86_64/repodata" ]; then
              echo "Existing repodata found, updating repository metadata..."
              echo "--- repodata before update ---"
              ls -la repo/rpm/x86_64/repodata || true
              echo "--- repomd.xml (head) ---"
              head -n 40 repo/rpm/x86_64/repodata/repomd.xml || true
              createrepo_c --update repo/rpm/x86_64/
              echo "--- repodata after update ---"
              ls -la repo/rpm/x86_64/repodata || true
              echo "--- repomd.xml (head) after update ---"
              head -n 40 repo/rpm/x86_64/repodata/repomd.xml || true
            else
              echo "No existing repodata found, generating repository metadata..."
              createrepo_c repo/rpm/x86_64/
              echo "--- repodata after generation ---"
              ls -la repo/rpm/x86_64/repodata || true
              echo "--- repomd.xml (head) ---"
              head -n 40 repo/rpm/x86_64/repodata/repomd.xml || true
            fi
            echo "RPM repository metadata generated successfully"
          else
            echo "No RPM packages found, skipping metadata generation"
          fi

      - name: Generate DEB repository metadata
        shell: bash
        run: |

          set -e

          DIST_NAME=stable
          PKG_NAME=switchboot
          PKG_LETTER=${PKG_NAME:0:1}

          if ! ls repo/deb/pool/main/$PKG_LETTER/$PKG_NAME/*.deb 1> /dev/null 2>&1; then
            echo "No DEB packages found, skipping metadata generation"
            exit 0
          fi

          echo "Generating DEB repository metadata..."
          cd repo/deb

          # Ensure dists directories exist (prune may have removed empty dirs)
          mkdir -p dists/$DIST_NAME/main/binary-amd64

          # Use apt-ftparchive to generate Packages and Release files with correct formatting
          apt-ftparchive packages pool/main/$PKG_LETTER/$PKG_NAME > dists/$DIST_NAME/main/binary-amd64/Packages
          gzip -kf dists/$DIST_NAME/main/binary-amd64/Packages

          # Generate a Release file with proper checksums and sizes, and set Codename and Suite for compatibility
          apt-ftparchive \
            -o APT::FTPArchive::Release::Codename=$DIST_NAME \
            -o APT::FTPArchive::Release::Suite=$DIST_NAME \
            release dists/$DIST_NAME > dists/$DIST_NAME/Release

          echo "DEB repository metadata generated successfully"

      - name: Sign repository metadata
        if: steps.secrets_check.outputs.have_gpg == 'true'
        shell: bash
        run: |
          set -e
          echo "Setting up GPG for signing..."
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --import

          # Sign RPM repository if it exists
          if [ -f "repo/rpm/x86_64/repodata/repomd.xml" ]; then
            echo "Signing RPM repository metadata..."
            # Remove old signature if it exists
            rm -f repo/rpm/x86_64/repodata/repomd.xml.asc repo/rpm/x86_64/repodata/repomd.xml.gpg
            gpg --batch --pinentry-mode loopback --passphrase "${{ secrets.GPG_PASSPHRASE }}" \
              --detach-sign --armor repo/rpm/x86_64/repodata/repomd.xml
            echo "RPM repository signed successfully"
          else
            echo "No RPM repository metadata found, skipping RPM signing"
          fi

          # Sign DEB repository if it exists
          if [ -f "repo/deb/dists/stable/Release" ]; then
            echo "Signing DEB repository metadata..."
            gpg --batch --pinentry-mode loopback --passphrase "${{ secrets.GPG_PASSPHRASE }}" \
              --clearsign --output repo/deb/dists/stable/InRelease repo/deb/dists/stable/Release
            gpg --batch --pinentry-mode loopback --passphrase "${{ secrets.GPG_PASSPHRASE }}" \
              --detach-sign --armor --output repo/deb/dists/stable/Release.gpg repo/deb/dists/stable/Release
            echo "DEB repository signed successfully"
          else
            echo "No DEB repository metadata found, skipping DEB signing"
          fi
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}

      - name: Create signatures archive
        shell: bash
        run: |
          set -e
          echo "Creating compressed archive of all signatures..."
          if [ -d "repo/signatures" ] && [ "$(ls -A repo/signatures 2>/dev/null)" ]; then
            cd repo
            tar -cJf signatures.tar.xz signatures/
            echo "Signatures archive created successfully:"
            ls -lh signatures.tar.xz
            echo "Archive contains:"
            tar -tJf signatures.tar.xz | head -20
            cd ..
          else
            echo "No signatures directory found or it's empty, skipping archive creation"
          fi

      - name: Create updates archive
        shell: bash
        run: |
          set -e
          echo "Creating compressed archive of all updates..."
          if [ -d "repo/updates" ] && [ "$(ls -A repo/updates 2>/dev/null)" ]; then
            cd repo
            tar -cJf updates.tar.xz updates/
            echo "Updates archive created successfully:"
            ls -lh updates.tar.xz
            echo "Archive contains:"
            tar -tJf updates.tar.xz | head -20
            cd ..
          else
            echo "No updates directory found or it's empty, skipping archive creation"
          fi

      - name: Generate directory indexes
        shell: bash
        run: |
          set -e
          echo "Generating final index.html files for repo/rpm and repo/deb only (not root repo/)"
          node --version || true
          chmod +x scripts/generate_indexes.js || true
          node scripts/generate_indexes.js repo/rpm repo/deb || true

      - name: Setup Pages
        uses: actions/configure-pages@v4

      - name: Upload repository to Pages
        uses: actions/upload-pages-artifact@v3
        with:
          path: ./repo

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
