name: Release Pipeline

on:
  push:
    branches:
      - release

permissions:
  contents: write
  pages: write
  id-token: write

concurrency:
  group: release-pipeline
  cancel-in-progress: true

jobs:
  # prepare: read the release version from src-tauri/tauri.conf.json and expose as job outputs
  prepare:
    name: Prepare release version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get_version.outputs.version }}
      tag: ${{ steps.get_version.outputs.tag }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Read version from tauri.conf.json
        id: get_version
        shell: bash
        run: |
          # Read version field from JSON and emit outputs
          ver=$(python -c "import json,sys;print(json.load(open('src-tauri/tauri.conf.json'))['version'])")
          echo "version=$ver" >> $GITHUB_OUTPUT
          echo "tag=v$ver" >> $GITHUB_OUTPUT

      - name: Check repository tags for existing or greater versions
        id: check_repo_tags
        shell: bash
        run: |
          set -euo pipefail
          TAG="${{ steps.get_version.outputs.tag }}"

          # If FORCE_REPO_UPDATE exists in repo-config, emit a visible warning and skip the check
          if [ -f repo-config/FORCE_REPO_UPDATE ]; then
            echo "::warning::FORCE_REPO_UPDATE present in repo-config/ — forcing repo update. Consider removing this file after use."
            exit 0
          fi

          echo "Checking existing git tags for versions >= $TAG"
          if ! python3 scripts/check_tag_against_repo.py "$TAG"; then
            rc=$?
            echo "::error::Tag check failed with exit code ${rc}. An equal or higher tag may already exist in the repository."
            echo "To override and force the repository update, create the file 'repo-config/FORCE_REPO_UPDATE' in the repository root and re-run the workflow (use with caution)."
            exit $rc
          fi

  build-linux:
    needs: prepare
    uses: ./.github/workflows/linux-build.yml
    with:
      tag: ${{ needs.prepare.outputs.tag }}
    secrets: inherit

  build-windows:
    needs: prepare
    uses: ./.github/workflows/windows-build.yml
    with:
      tag: ${{ needs.prepare.outputs.tag }}

  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    needs:
      - prepare
      - build-linux
      - build-windows

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download linux artifacts
        uses: actions/download-artifact@v4
        with:
          name: linux-artifacts-${{ needs.prepare.outputs.tag }}
          path: artifacts

      - name: Download windows artifacts
        uses: actions/download-artifact@v4
        with:
          name: windows-artifacts-${{ needs.prepare.outputs.tag }}
          path: artifacts

      - name: Show artifacts
        run: ls -la artifacts || true

      - name: Collect files to sign
        id: collect_files
        shell: bash
        run: |
          files=$(find artifacts -type f -name "*.deb" -o -name "*.rpm" -o -name "*.exe" | tr '\n' ';' | sed 's/;$//')
          echo "files=$files" >> $GITHUB_OUTPUT
          echo "Files to sign: $files"

      - name: Sign artifacts with GPG
        if: steps.collect_files.outputs.files != ''
        uses: ./.github/actions/gpg-sign
        with:
          files: ${{ steps.collect_files.outputs.files }}
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}

      - name: Set git user for CI tagging
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Ensure tag exists (delete existing tag only)
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TAG="${{ needs.prepare.outputs.tag }}"

          echo "Ensuring tag $TAG is created at current HEAD; if a remote tag exists it will be deleted first (release object will not be touched)"

          git fetch --prune --unshallow 2>/dev/null || true
          git fetch --prune origin

          # Use the credentials configured by actions/checkout (persist-credentials: true)
          # Avoid embedding tokens in remote URLs to reduce risk of accidental leakage

          if git ls-remote --tags origin "refs/tags/$TAG" | grep -q "refs/tags/$TAG"; then
            echo "Remote tag $TAG exists — deleting remote tag"
            git push origin :refs/tags/$TAG
          else
            echo "No remote tag $TAG found"
          fi

          # Delete local tag if present
          if git rev-parse -q --verify "refs/tags/$TAG" >/dev/null; then
            echo "Local tag $TAG exists — deleting local tag"
            git tag -d "$TAG" || true
          fi

          # Create annotated tag at current HEAD and push
          echo "Creating annotated tag $TAG at HEAD"
          git tag -a "$TAG" -m "Release $TAG"
          git push origin "refs/tags/$TAG"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.prepare.outputs.tag }}
          name: Switchboot ${{ needs.prepare.outputs.tag }}
          body: |
            Switchboot ${{ needs.prepare.outputs.tag }} released
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload artifacts to release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.prepare.outputs.tag }}
          files: artifacts/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  update-repository:
    needs:
      - prepare
      - create-release
    uses: ./.github/workflows/update-repository.yml
    with:
      tag: ${{ needs.prepare.outputs.tag }}
    secrets: inherit
