name: Linux Build

permissions:
  contents: write

on:
  workflow_call:
    inputs:
      tag:
        description: "Optional git tag (e.g. v0.1.1)"
        required: false
        type: string

concurrency:
  group: linux-build
  cancel-in-progress: true

jobs:
  build-linux:
    name: Build Linux App
    runs-on: ubuntu-22.04
    env:
      CALL_TAG: ${{ inputs.tag }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Compute release version
        id: ver
        shell: bash
        run: |
          if [ -n "${CALL_TAG:-}" ]; then
            # CALL_TAG is expected like 'v0.1.1' or '0.1.1'
            ver="${CALL_TAG#v}"
          elif [[ "$GITHUB_REF" =~ refs/tags/v(.+) ]]; then
            ver="${BASH_REMATCH[1]}"
          else
            ver=$(python -c "import json,sys;print(json.load(open('src-tauri/tauri.conf.json'))['version'])")
          fi
          echo "version=$ver" >> $GITHUB_OUTPUT
          echo "tag=v$ver" >> $GITHUB_OUTPUT

      - name: Check for GPG secret
        id: secrets_check
        shell: bash
        run: |
          if [ -n "${{ secrets.GPG_PRIVATE_KEY }}" ]; then
            echo "have_gpg=true" >> $GITHUB_OUTPUT
          else
            echo "have_gpg=" >> $GITHUB_OUTPUT
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: "latest"

      - name: Cache pnpm store and node_modules
        uses: actions/cache@v4
        with:
          path: |
            ~/.pnpm-store
            node_modules
          key: pnpm-${{ runner.os }}-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            pnpm-${{ runner.os }}-

      - name: Install dependencies
        run: pnpm install

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            curl \
            ca-certificates \
            git \
            pkg-config \
            cmake \
            unzip \
            libssl-dev \
            libglib2.0-dev \
            libsoup-3.0-dev \
            libwebkit2gtk-4.1-dev \
            libjavascriptcoregtk-4.1-dev \
            libgtk-3-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev

      - name: Install mold v2.40.4
        run: |
          set -e
          echo "Installing mold v2.40.4 (pinned)..."
          # Query the GitHub release for tag v2.40.4 and pick an x86_64 tarball asset
          MOLD_URL=$(curl -s https://api.github.com/repos/rui314/mold/releases/tags/v2.40.4 \
            | grep "browser_download_url" | grep -E "x86_64.*tar.gz" | head -n1 | cut -d '"' -f4 || true)
          if [ -n "$MOLD_URL" ]; then
            echo "Found mold release: $MOLD_URL"
            curl -L "$MOLD_URL" -o /tmp/mold.tar.gz
            mkdir -p /tmp/moldtmp
            tar -xzf /tmp/mold.tar.gz -C /tmp/moldtmp
            # copy any bin files from the extracted archive into /usr/local/bin
            if [ -d /tmp/moldtmp/bin ]; then
              sudo cp /tmp/moldtmp/bin/* /usr/local/bin/ || true
              sudo chmod +x /usr/local/bin/* || true
            else
              # try to locate mold binary anywhere in the extracted tree
              MOLD_BIN=$(find /tmp/moldtmp -type f -name mold -print -quit || true)
              if [ -n "$MOLD_BIN" ]; then
                sudo cp "$MOLD_BIN" /usr/local/bin/mold || true
                sudo chmod +x /usr/local/bin/mold || true
              else
                echo "mold binary not found in archive; skipping copy"
              fi
            fi
          else
            echo "Could not locate a mold release for x86_64; skipping mold install"
          fi

      - name: Install Rust (rustup)
        shell: bash
        run: |
          # Install rustup and set stable toolchain as default
          curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --default-toolchain stable
          source $HOME/.cargo/env
          rustup default stable
          # add commonly useful components
          rustup component add rust-src || true
          # persist cargo bin in subsequent steps
          echo "$HOME/.cargo/bin" >> $GITHUB_PATH

      - name: Cache Cargo registry and git
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          key: cargo-registry-${{ runner.os }}-${{ hashFiles('src-tauri/Cargo.lock') }}
          restore-keys: |
            cargo-registry-${{ runner.os }}-

      # Optional: cache the Rust build target directory to speed up repeated CI runs.
      - name: Cache Cargo build target (optional)
        uses: actions/cache@v4
        with:
          path: src-tauri/target
          key: cargo-target-${{ runner.os }}-${{ hashFiles('src-tauri/Cargo.lock') }}
          restore-keys: |
            cargo-target-${{ runner.os }}-

      - name: Build frontend and Tauri (no bundle)
        run: |
          pnpm tauri icon ./app-icon.svg
          pnpm icons
          pnpm tauri build --no-bundle

      - name: Bundle Tauri (deb & rpm)
        run: pnpm tauri bundle

      - name: Collect artifacts
        id: collect
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p artifacts
          echo "Looking for bundles under src-tauri/target/release/bundle"
          ls -la src-tauri/target/release/bundle || true
          # enable nullglob so globs that match nothing expand to nothing
          shopt -s nullglob
          deb_files=(src-tauri/target/release/bundle/deb/*.deb)
          rpm_files=(src-tauri/target/release/bundle/rpm/*.rpm)
          if [ ${#deb_files[@]} -gt 0 ]; then
            deb="${deb_files[@]: -1}"
            echo "Found deb: $deb"
            cp "$deb" artifacts/
            debname=$(basename "$deb")
            echo "deb_artifact=$debname" >> $GITHUB_OUTPUT
          fi
          if [ ${#rpm_files[@]} -gt 0 ]; then
            rpm="${rpm_files[@]: -1}"
            echo "Found rpm: $rpm"
            cp "$rpm" artifacts/
            rpmname=$(basename "$rpm")
            echo "rpm_artifact=$rpmname" >> $GITHUB_OUTPUT
          fi
          echo "Artifacts dir contents after copy:"
          ls -la artifacts || true
          if [ ${#deb_files[@]} -eq 0 ] && [ ${#rpm_files[@]} -eq 0 ]; then
            echo "No deb or rpm artifact found under src-tauri/target/release/bundle"
            ls -R src-tauri/target/release/bundle || true
            exit 1
          fi

      - name: Install RPM signing tools (rpm, gnupg, expect)
        if: steps.secrets_check.outputs.have_gpg == 'true'
        shell: bash
        run: |
          set -e
          echo "Installing packages required for signing RPMs..."
          sudo apt-get update
          sudo apt-get install -y rpm gnupg expect

      - name: Sign RPM packages (embed signature)
        if: steps.secrets_check.outputs.have_gpg == 'true'
        shell: bash
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          set -euxo pipefail
          echo "Listing artifacts before signing:"
          ls -la artifacts || true
          shopt -s nullglob
          rpm_files=(artifacts/*.rpm)
          if [ ${#rpm_files[@]} -eq 0 ]; then
            echo "No RPMs to sign in artifacts/; aborting."
            exit 1
          fi
          echo "RPMs to sign: ${rpm_files[*]}"
          echo "Importing GPG private key for RPM signing..."
          echo "$GPG_PRIVATE_KEY" | gpg --batch --import

          # Determine GPG user name from the imported secret key
          GPG_KEY_NAME=$(gpg --list-secret-keys --with-colons | awk -F: '/^uid:/ {print $10; exit}')
          if [ -z "$GPG_KEY_NAME" ]; then
            echo "Failed to determine GPG key name" >&2
            exit 1
          fi

          echo "Configuring rpm macros for GPG: $GPG_KEY_NAME"
          mkdir -p ~/.gnupg
          # Ensure gpg uses loopback pinentry for non-interactive passphrase
          echo "allow-loopback-pinentry" >> ~/.gnupg/gpg-agent.conf || true
          gpgconf --kill gpg-agent || true
          echo "%_signature gpg" > ~/.rpmmacros
          echo "%_gpg_name $GPG_KEY_NAME" >> ~/.rpmmacros

          # Sign each rpm in-place using expect to provide passphrase
          for rpm in "${rpm_files[@]}"; do
            if [ -f "$rpm" ]; then
              echo "Signing $rpm"
              expect -c "log_user 1; spawn rpm --addsign '$rpm'; expect -re \"Enter pass phrase:\"; send -- \"$GPG_PASSPHRASE\r\"; expect eof"
            else
              echo "Skipping missing file $rpm"
            fi
          done

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: linux-artifacts-${{ steps.ver.outputs.tag }}
          path: artifacts/*
