name: Linux Build

permissions:
  contents: write

on:
  workflow_call:
    inputs:
      tag:
        description: "Optional git tag (e.g. v0.1.1)"
        required: false
        type: string

concurrency:
  group: linux-build
  cancel-in-progress: true

jobs:
  build-linux:
    name: Build Linux App
    runs-on: ubuntu-22.04
    env:
      CALL_TAG: ${{ inputs.tag }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Compute release version
        id: ver
        shell: bash
        run: |
          if [ -n "${CALL_TAG:-}" ]; then
            # CALL_TAG is expected like 'v0.1.1' or '0.1.1'
            ver="${CALL_TAG#v}"
          elif [[ "$GITHUB_REF" =~ refs/tags/v(.+) ]]; then
            ver="${BASH_REMATCH[1]}"
          else
            ver=$(python -c "import json,sys;print(json.load(open('src-tauri/tauri.conf.json'))['version'])")
          fi
          echo "version=$ver" >> $GITHUB_OUTPUT
          echo "tag=v$ver" >> $GITHUB_OUTPUT

      - name: Check for GPG secret
        id: secrets_check
        shell: bash
        run: |
          if [ -n "${{ secrets.GPG_PRIVATE_KEY }}" ]; then
            echo "have_gpg=true" >> $GITHUB_OUTPUT
          else
            echo "have_gpg=" >> $GITHUB_OUTPUT
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: "latest"

      - name: Cache pnpm store and node_modules
        uses: actions/cache@v4
        with:
          path: |
            ~/.pnpm-store
            node_modules
          key: pnpm-${{ runner.os }}-${{ hashFiles('**/pnpm-lock.yaml') }}

      - name: Install dependencies
        run: pnpm install

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            curl \
            ca-certificates \
            git \
            pkg-config \
            cmake \
            unzip \
            libssl-dev \
            libglib2.0-dev \
            libsoup-3.0-dev \
            libwebkit2gtk-4.1-dev \
            libjavascriptcoregtk-4.1-dev \
            libgtk-3-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev

      - name: Install Rust (rustup)
        shell: bash
        run: |
          # Install rustup and set stable toolchain as default
          curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --default-toolchain stable
          source $HOME/.cargo/env
          rustup default stable
          # add commonly useful components
          rustup component add rust-src || true
          # persist cargo bin in subsequent steps
          echo "$HOME/.cargo/bin" >> $GITHUB_PATH

      - name: Capture Rust toolchain version
        id: rustver
        shell: bash
        run: |
          # capture a concise rust toolchain string (e.g. 1.76.0)
          if command -v rustc >/dev/null 2>&1; then
            rv=$(rustc --version | awk '{print $2}') || rv="unknown"
          else
            rv="unknown"
          fi
          echo "rust_version=$rv" >> $GITHUB_OUTPUT

      - name: Cache Cargo registry and git
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          key: cargo-registry-${{ runner.os }}-${{ steps.rustver.outputs.rust_version }}

      # Optional: cache the Rust build target directory to speed up repeated CI runs.
      - name: Cache Cargo build target (optional)
        uses: actions/cache@v4
        with:
          path: src-tauri/target
          key: cargo-target-${{ runner.os }}-${{ steps.rustver.outputs.rust_version }}

      - name: Build frontend and Tauri (no bundle)
        run: |
          pnpm tauri icon ./app-icon.svg
          pnpm icons
          pnpm tauri build --no-bundle

      - name: Bundle Tauri (deb & rpm)
        run: pnpm tauri bundle

      - name: Collect artifacts
        id: collect
        shell: bash
        run: |
          mkdir -p artifacts
          # prefer the standard subfolders produced by Tauri
          deb=$(ls src-tauri/target/release/bundle/deb/*.deb 2>/dev/null | tail -n 1 || true)
          rpm=$(ls src-tauri/target/release/bundle/rpm/*.rpm 2>/dev/null | tail -n 1 || true)
          if [ -n "$deb" ]; then
            cp "$deb" artifacts/
            debname=$(basename "$deb")
            echo "deb_artifact=$debname" >> $GITHUB_OUTPUT
          fi
          if [ -n "$rpm" ]; then
            cp "$rpm" artifacts/
            rpmname=$(basename "$rpm")
            echo "rpm_artifact=$rpmname" >> $GITHUB_OUTPUT
          fi
          if [ -z "$deb" -a -z "$rpm" ]; then
            echo "No deb or rpm artifact found under src-tauri/target/release/bundle"
            ls -R src-tauri/target/release/bundle || true
            exit 1
          fi

      - name: Install RPM signing tools (rpm, gnupg, expect)
        if: steps.secrets_check.outputs.have_gpg == 'true'
        shell: bash
        run: |
          set -e
          echo "Installing packages required for signing RPMs..."
          sudo apt-get update
          sudo apt-get install -y rpm gnupg expect

      - name: Debug artifacts directory before signing
        if: steps.secrets_check.outputs.have_gpg == 'true'
        shell: bash
        run: |
          set -e
          echo "Current working directory: $(pwd)"
          echo "Listing artifacts directory:"
          ls -l "$(pwd)/artifacts" || true
          echo "Listing RPM files in artifacts:"
          ls -l "$(pwd)"/artifacts/*.rpm || true

      - name: Sign RPM packages (embed signature)
        if: steps.secrets_check.outputs.have_gpg == 'true'
        shell: bash
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          set -e
          echo "Importing GPG private key for RPM signing..."
          echo "$GPG_PRIVATE_KEY" | gpg --batch --import

          # Determine GPG user name from the imported secret key
          GPG_KEY_NAME=$(gpg --list-secret-keys --with-colons | awk -F: '/^uid:/ {print $10; exit}')
          if [ -z "$GPG_KEY_NAME" ]; then
            echo "Failed to determine GPG key name" >&2
            exit 1
          fi

          echo "Configuring rpm macros for GPG: $GPG_KEY_NAME"
          mkdir -p ~/.gnupg
          # Ensure gpg uses loopback pinentry for non-interactive passphrase
          echo "allow-loopback-pinentry" >> ~/.gnupg/gpg-agent.conf || true
          gpgconf --kill gpg-agent || true
          echo "%_signature gpg" > ~/.rpmmacros
          echo "%_gpg_name $GPG_KEY_NAME" >> ~/.rpmmacros
          # Force RPM to use gpg with loopback pinentry and supply passphrase non-interactively
          echo "%__gpg /usr/bin/gpg" >> ~/.rpmmacros
          echo "%__gpg_sign_cmd %{__gpg} gpg --batch --yes --pinentry-mode loopback --passphrase \"$GPG_PASSPHRASE\" -u \"%{_gpg_name}\" -sbo %{__signature_filename} %{__plaintext_filename}" >> ~/.rpmmacros

          # Use absolute path for RPM files and sign directly (no expect)
          for rpm in $(ls -1 "$(pwd)/artifacts"/*.rpm 2>/dev/null); do
            if [ -f "$rpm" ]; then
              echo "Signing $rpm"
              rpm --addsign "$rpm"
            else
              echo "RPM not found: $rpm"
            fi
          done

          # Cleanup sensitive signing artifacts and environment
          echo "Cleaning up signing artifacts"
          # securely remove rpmmacros which contains the passphrase
          if [ -f "$HOME/.rpmmacros" ]; then
            shred -u -z "$HOME/.rpmmacros" 2>/dev/null || rm -f "$HOME/.rpmmacros" || true
          fi
          # clear passphrase from environment
          unset GPG_PASSPHRASE || true
          export GPG_PASSPHRASE=''

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: linux-artifacts-${{ steps.ver.outputs.tag }}
          path: artifacts/*
