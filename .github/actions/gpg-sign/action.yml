name: "GPG Sign"
description: "Composite action to create detached ASCII-armored GPG signatures for files.
Requires GPG_PRIVATE_KEY (ASCII armoured) and optionally GPG_PASSPHRASE as secrets."
inputs:
  files:
    description: "Semicolon-separated list of file paths to sign (relative to workspace)."
    required: true
runs:
  using: "composite"
  steps:
    - name: Import key and sign files (POSIX)
      if: runner.os != 'Windows'
      shell: bash
      run: |
        set -euo pipefail
        filesRaw='${{ inputs.files }}'
        IFS=';'
        read -ra filesArr <<< "$filesRaw"

        if [ -z "${GPG_PRIVATE_KEY:-}" ]; then
          echo "Environment variable GPG_PRIVATE_KEY must be provided." >&2
          exit 1
        fi

        gnupghome=$(mktemp -d)
        export GNUPGHOME="$gnupghome"

        echo "$GPG_PRIVATE_KEY" > "$gnupghome/private.key"
        gpg --batch --import "$gnupghome/private.key"

        for f in "${filesArr[@]}"; do
          # trim
          f="$(echo "$f" | xargs)"
          [ -z "$f" ] && continue
          if [ -f "$f" ]; then
            echo "Signing $f"
            if [ -n "${GPG_PASSPHRASE:-}" ]; then
              gpg --batch --yes --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" --armor --detach-sign -o "$f.asc" "$f"
            else
              gpg --batch --yes --armor --detach-sign -o "$f.asc" "$f"
            fi
          else
            echo "Not found, skipping: $f"
          fi
        done

        # cleanup private key file
        rm -f "$gnupghome/private.key"

    - name: Import key and sign files (Windows)
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        $ErrorActionPreference = 'Stop'
        $filesRaw = '${{ inputs.files }}'
        $files = $filesRaw -split ';' | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' }

        if (-not $env:GPG_PRIVATE_KEY) {
          Write-Error 'Environment variable GPG_PRIVATE_KEY must be provided.'
          exit 1
        }

        $gnupghome = Join-Path $env:RUNNER_TEMP 'gnupghome'
        New-Item -ItemType Directory -Path $gnupghome -Force | Out-Null
        $env:GNUPGHOME = $gnupghome

        # Print GPG version and a few debug lines up-front
        Write-Host 'GPG debug info:'
        $gpgOk = $false
        if (Get-Command gpg -ErrorAction SilentlyContinue) {
          try {
            gpg --version | ForEach-Object { Write-Host "  $_" }
            gpgconf --list-dirs | ForEach-Object { Write-Host "  $($_)" }
            gpgconf --list-options gpg-agent | ForEach-Object { Write-Host "  $($_)" }
            $gpgOk = $true
          } catch {
            Write-Warning "gpg present but --version/debug checks failed: $_"
            $gpgOk = $false
          }
        } else {
          Write-Warning 'gpg not found'
        }

        # If gpg is missing or failing basic checks, try to install a Windows-native GnuPG via winget
        if (-not $gpgOk) {
          Write-Host 'Attempting to install GnuPG (Gpg4win) using winget (no choco)...'
          if (Get-Command winget -ErrorAction SilentlyContinue) {
            try {
              winget install --id GnuPG.Gpg4win --accept-source-agreements --accept-package-agreements -e
              Write-Host 'winget install finished; re-checking gpg'
            } catch {
              Write-Warning "winget install failed: $_"
            }
          } else {
            Write-Warning 'winget not available on runner; cannot auto-install GnuPG'
          }

          # try to pick up newly-installed gpg
          Start-Sleep -Seconds 2
          if (Get-Command gpg -ErrorAction SilentlyContinue) {
            try {
              gpg --version | ForEach-Object { Write-Host "  $_" }
              $gpgOk = $true
            } catch {
              Write-Warning "gpg still not usable after install attempt: $_"
            }
          } else {
            Write-Warning 'gpg still not found after install attempt'
          }
        }

        # Attempt to reload agent and kill it with delays; always continue and log outcome
        Write-Host 'Attempting: gpg-connect-agent reloadagent /bye'
        if (Get-Command gpg-connect-agent -ErrorAction SilentlyContinue) {
          try {
            gpg-connect-agent reloadagent /bye
            Write-Host 'gpg-connect-agent reloadagent succeeded'
          } catch {
            Write-Warning "gpg-connect-agent reloadagent failed: $_"
          }
        } else {
          Write-Warning 'gpg-connect-agent not found'
        }
        Start-Sleep -Seconds 2

        $keyPath = Join-Path $gnupghome 'private.key'
        [System.IO.File]::WriteAllText($keyPath, $env:GPG_PRIVATE_KEY)
        gpg --batch --import $keyPath

        foreach ($file in $files) {
          if (Test-Path $file) {
            Write-Host "Signing $file"
            if ($env:GPG_PASSPHRASE) {
              gpg --batch --yes --pinentry-mode loopback --passphrase "$env:GPG_PASSPHRASE" --armor --detach-sign -o "$file.asc" $file
            } else {
              gpg --batch --yes --armor --detach-sign -o "$file.asc" $file
            }
          } else {
            Write-Host "Not found, skipping: $file"
          }
        }

        # cleanup private key file; keep GNUPGHOME folder for possible verification steps
        Remove-Item $keyPath -Force
