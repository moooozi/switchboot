name: "GPG Sign"
description: "Composite action to create detached ASCII-armored GPG signatures for files.
Requires GPG_PRIVATE_KEY (ASCII armoured) and optionally GPG_PASSPHRASE as secrets."
inputs:
  files:
    description: "Semicolon-separated list of file paths to sign (relative to workspace)."
    required: true
runs:
  using: "composite"
  steps:
    - name: Import key and sign files (POSIX)
      if: runner.os != 'Windows'
      shell: bash
      run: |
        set -euo pipefail
        filesRaw='${{ inputs.files }}'
        IFS=';'
        read -ra filesArr <<< "$filesRaw"

        if [ -z "${GPG_PRIVATE_KEY:-}" ]; then
          echo "Environment variable GPG_PRIVATE_KEY must be provided." >&2
          exit 1
        fi

        gnupghome=$(mktemp -d)
        export GNUPGHOME="$gnupghome"

        echo "$GPG_PRIVATE_KEY" > "$gnupghome/private.key"
        gpg --batch --import "$gnupghome/private.key"

        for f in "${filesArr[@]}"; do
          # trim
          f="$(echo "$f" | xargs)"
          [ -z "$f" ] && continue
          if [ -f "$f" ]; then
            echo "Signing $f"
            if [ -n "${GPG_PASSPHRASE:-}" ]; then
              gpg --batch --yes --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" --armor --detach-sign -o "$f.asc" "$f"
            else
              gpg --batch --yes --armor --detach-sign -o "$f.asc" "$f"
            fi
          else
            echo "Not found, skipping: $f"
          fi
        done

        # cleanup private key file
        rm -f "$gnupghome/private.key"

    - name: Import key and sign files (Windows)
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        $ErrorActionPreference = 'Stop'

        $filesRaw = '${{ inputs.files }}'
        $files = $filesRaw -split ';' | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' }

        if (-not $env:GPG_PRIVATE_KEY) {
          Write-Error 'Environment variable GPG_PRIVATE_KEY must be provided.'
          exit 1
        }

        # Create isolated GPG home for the runner
        $gnupghome = Join-Path $env:RUNNER_TEMP 'gnupghome'
        New-Item -ItemType Directory -Path $gnupghome -Force | Out-Null
        $env:GNUPGHOME = $gnupghome

        $keyPath = Join-Path $gnupghome 'private.key'
        [System.IO.File]::WriteAllText($keyPath, $env:GPG_PRIVATE_KEY)

        # Kill any leftover gpg-agent and restart via gpgconf to ensure sockets are created inside our GNUPGHOME
        try { Get-Process gpg-agent -ErrorAction SilentlyContinue | Stop-Process -Force -ErrorAction SilentlyContinue } catch { }
        & gpgconf --kill gpg-agent 2>$null || $true
        Start-Sleep -Milliseconds 200
        & gpgconf --launch gpg-agent 2>$null || $true

        # Try to import the private key. If a passphrase is provided, request loopback pinentry so operations don't require an external pinentry GUI.
        if ($env:GPG_PASSPHRASE) {
          Write-Host "Importing private key (using loopback pinentry)"
          & gpg --homedir $gnupghome --batch --yes --pinentry-mode loopback --passphrase "$env:GPG_PASSPHRASE" --import $keyPath
        } else {
          Write-Host "Importing private key"
          & gpg --homedir $gnupghome --batch --yes --import $keyPath
        }

        # Determine the secret key id that was imported (long keyid / fingerprint)
        $secretKey = & gpg --homedir $gnupghome --list-secret-keys --with-colons | Select-String -Pattern '^sec' | ForEach-Object { $_.ToString().Split(':')[4] } | Select-Object -First 1
        if (-not $secretKey) {
          Write-Host "No secret key found after import; listing keys for debugging"
          & gpg --homedir $gnupghome --list-secret-keys --keyid-format LONG
        } else {
          Write-Host "Using secret key: $secretKey"
        }

        foreach ($file in $files) {
          if (Test-Path $file) {
            Write-Host "Signing $file"
            if ($secretKey) {
              if ($env:GPG_PASSPHRASE) {
                & gpg --homedir $gnupghome --batch --yes --pinentry-mode loopback --passphrase "$env:GPG_PASSPHRASE" --default-key $secretKey --armor --detach-sign -o "$file.asc" $file
              } else {
                & gpg --homedir $gnupghome --batch --yes --default-key $secretKey --armor --detach-sign -o "$file.asc" $file
              }
            } else {
              # Fallback: attempt to sign without specifying key (may fail if no default)
              if ($env:GPG_PASSPHRASE) {
                & gpg --homedir $gnupghome --batch --yes --pinentry-mode loopback --passphrase "$env:GPG_PASSPHRASE" --armor --detach-sign -o "$file.asc" $file
              } else {
                & gpg --homedir $gnupghome --batch --yes --armor --detach-sign -o "$file.asc" $file
              }
            }
          } else {
            Write-Host "Not found, skipping: $file"
          }
        }

        # cleanup private key file; keep GNUPGHOME folder for possible verification steps
        Remove-Item $keyPath -Force
