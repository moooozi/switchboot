name: "GPG Sign"
description: "Composite action to create detached ASCII-armored GPG signatures for files.
Requires GPG_PRIVATE_KEY (ASCII armoured) and optionally GPG_PASSPHRASE as secrets."
inputs:
  files:
    description: "Semicolon-separated list of file paths to sign (relative to workspace)."
    required: true
runs:
  using: "composite"
  steps:
    - name: Import key and sign files (POSIX)
      if: runner.os != 'Windows'
      shell: bash
      run: |
        set -euo pipefail
        filesRaw='${{ inputs.files }}'
        IFS=';'
        read -ra filesArr <<< "$filesRaw"

        if [ -z "${GPG_PRIVATE_KEY:-}" ]; then
          echo "Environment variable GPG_PRIVATE_KEY must be provided." >&2
          exit 1
        fi

        gnupghome=$(mktemp -d)
        export GNUPGHOME="$gnupghome"

        echo "$GPG_PRIVATE_KEY" > "$gnupghome/private.key"
        gpg --batch --import "$gnupghome/private.key"

        for f in "${filesArr[@]}"; do
          # trim
          f="$(echo "$f" | xargs)"
          [ -z "$f" ] && continue
          if [ -f "$f" ]; then
            echo "Signing $f"
            if [ -n "${GPG_PASSPHRASE:-}" ]; then
              gpg --batch --yes --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" --armor --detach-sign -o "$f.asc" "$f"
            else
              gpg --batch --yes --armor --detach-sign -o "$f.asc" "$f"
            fi
          else
            echo "Not found, skipping: $f"
          fi
        done

        # cleanup private key file
        rm -f "$gnupghome/private.key"

    - name: Import key and sign files (Windows)
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        $ErrorActionPreference = 'Stop'
        $filesRaw = '${{ inputs.files }}'
        $files = $filesRaw -split ';' | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' }

        if (-not $env:GPG_PRIVATE_KEY) {
          Write-Error 'Environment variable GPG_PRIVATE_KEY must be provided.'
          exit 1
        }

        # Install a known-good GnuPG on the Windows runner. The preinstalled gpg can be unreliable.
        Write-Host 'Installing gnupg via Chocolatey (if not already present)'
        choco feature disable -n showDownloadProgress | Out-Null
        choco install gnupg -y --no-progress

        $gnupghome = Join-Path $env:RUNNER_TEMP 'gnupghome'
        New-Item -ItemType Directory -Path $gnupghome -Force | Out-Null
        $env:GNUPGHOME = $gnupghome

        $keyPath = Join-Path $gnupghome 'private.key'
        [System.IO.File]::WriteAllText($keyPath, $env:GPG_PRIVATE_KEY)

        # Ensure gpg-agent is not holding old state and allow loopback pinentry for scripted passphrases
        Write-Host 'Configuring gpg-agent to allow loopback pinentry'
        $gpgAgentConf = Join-Path $gnupghome 'gpg-agent.conf'
        "allow-loopback-pinentry" | Out-File -FilePath $gpgAgentConf -Encoding ascii
        # Kill any running agent so new config is picked up
        & gpgconf --kill gpg-agent 2>$null || Write-Host 'No gpg-agent to kill or gpgconf missing; continuing'

        # Launch gpg-agent so subsequent operations can talk to it. Prefer gpgconf, fallback to gpg-agent --daemon.
        try {
          Write-Host 'Launching gpg-agent via gpgconf --launch gpg-agent'
          & gpgconf --launch gpg-agent
          Write-Host 'gpg-agent launched'
        } catch {
          Write-Host 'gpgconf launch failed; attempting gpg-agent --daemon'
          try {
            Start-Process -NoNewWindow -FilePath 'gpg-agent' -ArgumentList '--daemon' -PassThru | Out-Null
            Write-Host 'gpg-agent started via gpg-agent --daemon'
          } catch {
            Write-Host 'Failed to start gpg-agent; import/sign may still fail'
          }
        }

        Write-Host 'Importing private key'
        # Use --pinentry-mode loopback for import to avoid external pinentry
        & gpg --batch --yes --pinentry-mode loopback --import $keyPath

        foreach ($file in $files) {
          if (Test-Path $file) {
            Write-Host "Signing $file"
            if ($env:GPG_PASSPHRASE) {
              & gpg --batch --yes --pinentry-mode loopback --passphrase "$env:GPG_PASSPHRASE" --armor --detach-sign -o "$file.asc" $file
            } else {
              & gpg --batch --yes --pinentry-mode loopback --armor --detach-sign -o "$file.asc" $file
            }
          } else {
            Write-Host "Not found, skipping: $file"
          }
        }

        # cleanup private key file; keep GNUPGHOME folder for possible verification steps
        Remove-Item $keyPath -Force
